# --------------------------------------------------------------------
# recipe.py: Recipe base classes and utilities.
#
# Author: Lain Musgrove (lain.proliant@gmail.com)
# Date: Wednesday, August 12 2020
#
# Distributed under terms of the MIT license.
# --------------------------------------------------------------------
import asyncio
import itertools
import shutil
from datetime import datetime, timedelta
from pathlib import Path
from typing import Generic, List, Optional, Set, TypeVar, Iterable

from .errors import BuildError

# --------------------------------------------------------------------
T = TypeVar("T")


# --------------------------------------------------------------------
class Artifact:
    """ An abstract class representing the output of a recipe, e.g. a
    static file or a resulting system state, which can be used to
    reverse the state or clean the output. """

    async def clean(self):
        """ Delete the output or reverse the state this artifact represents. """
        raise NotImplementedError()

    @property
    def exists(self) -> bool:
        """ Determine if the output or system state this artifact represents
        actually exists. """
        raise NotImplementedError()

    @property
    def age(self) -> timedelta:
        """ Determine the age of this artifact. """
        return timedelta.max

    def to_param(self):
        raise NotImplementedError()


# --------------------------------------------------------------------
class Value(Artifact, Generic[T]):
    """ Represents a constant value generated by a recipe. """

    def __init__(self, value: T):
        self._value: T = value

    async def clean(self):
        pass

    @property
    def exists(self) -> bool:
        return True

    @property
    def value(self) -> T:
        return self._value

    def to_param(self) -> List[str]:
        return [str(self._value)]


# --------------------------------------------------------------------
class File(Artifact):
    """ Represents a file or directory output from a recipe. """

    def __init__(self, path: Path):
        self.path = path

    @property
    def exists(self) -> bool:
        return self.path.exists()

    @property
    def age(self) -> timedelta:
        return datetime.now() - datetime.fromtimestamp(self.path.stat().st_mtime)

    async def clean(self):
        if self.path.is_dir():
            shutil.rmtree(self.path)
        else:
            self.path.unlink()

    def __repr__(self):
        return f"<File {str(self.path)}>"

    def __str__(self):
        return str(self.path)

    def to_param(self) -> List[str]:
        return [str(self)]


# --------------------------------------------------------------------
class Recipe:
    """ Represents a repeatable process. """

    def __init__(self, requires: Optional[List["Recipe"]] = None):
        self._deps: List["Recipe"] = requires or []

    @property
    def is_done(self) -> bool:
        """ Determine if all of the artifacts of this recipe exist and
        are up to date.  Will always return false if there are no artifacts
        made by this recipe. """
        artifacts_exist = self.creates and all(output.exists for output in self.creates)
        if not artifacts_exist:
            return False
        inputs_exist = any(dep.exists for dep in self.inputs)
        if inputs_exist:
            newest_dep_age = min(dep.age for dep in self.inputs)
            return any(output.age > newest_dep_age for output in self.creates)
        return True

    def assert_is_done(self):
        if not self.is_done:
            raise BuildError(f"{repr(self)} did not complete successfully.")

    async def make(self):
        """ Execute this recipe in order to create its artifacts, if any. """
        raise NotImplementedError()

    def make_sync(self, loop=asyncio.get_event_loop()):
        """ Execute this recipe in order to create its artifacts, if any.
        Can be called outside but not within an event loop. """
        loop.run_until_complete(self.make())

    async def make_deps(self):
        """ Make all dependencies of this recipe. """
        await asyncio.gather(
            *(recipe.make() for recipe in self.dependencies if not recipe.is_done)
        )
        for recipe in self.dependencies:
            recipe.assert_is_done()

    def make_deps_sync(self, loop=asyncio.get_event_loop()):
        """ Make all dependencies of this recipe.
        Can be called outside but not within an event loop. """
        loop.run_until_complete(self.make_deps())

    async def resolve(self):
        """ Execute this recipe and all its dependencies, if any. """
        await self.make_deps()
        if not self.is_done:
            await self.make()

    def resolve_sync(self, loop=asyncio.get_event_loop()):
        """ Execute this recipe and all of its dependencies, if any.
        Can be called outside but not within an event loop. """
        loop.run_until_complete(self.resolve())

    async def clean(self):
        """ Clean all of the artifacts this recipe would make, if any. """
        await asyncio.gather(*(artifact.clean() for artifact in self.creates))

    def clean_sync(self, loop=asyncio.get_event_loop()):
        """ Clean all of the artifacts this recipe would make, if any.
        Can be called outside but not within an event loop. """
        loop.run_until_complete(self.clean())

    async def purge(self):
        """ Clean this and all dependencies. """
        await asyncio.gather(self.clean(), *(dep.purge() for dep in self.dependencies))

    def purge_sync(self, loop=asyncio.get_event_loop()):
        """ Clean this and all dependencies.
        Can be called outside but not within an event loop. """
        loop.run_until_coomplete(self.purge())

    @property
    def creates(self) -> List[Artifact]:
        """ List of the artifacts made by this recipe.  This should reflect the
        reversible system states changed by executing this recipe. """
        return []

    @property
    def inputs(self) -> List[Artifact]:
        """ List of artifacts that this recipe uses.  Defined by the artifacts
        generated by its dependencies. """
        return [*itertools.chain(*[dep.creates for dep in self.dependencies])]

    @property
    def dependencies(self) -> List["Recipe"]:
        """ List of the recipes that must be completed before this recipe can
        be executed. """
        return self._deps

    def __repr__(self):
        return (
            f"<{self.__class__.__name__} for "
            f"{','.join(repr(output for output in self.creates))}>"
        )
        raise NotImplementedError()


# --------------------------------------------------------------------
class PolyRecipe(Recipe):
    @classmethod
    def _calculate_deps(cls, *recipes: Recipe) -> List[Recipe]:
        deps_set: Set[Recipe] = set()
        for recipe in recipes:
            deps_set.update(recipe.dependencies)
        return [*deps_set]

    def __init__(self, recipes: Iterable[Recipe]):
        super().__init__(self._calculate_deps(*recipes))
        self._recipes = recipes

    @property
    def creates(self) -> List[Artifact]:
        return [*itertools.chain(*[recipe.creates for recipe in self._recipes])]

    async def make(self):
        await asyncio.gather(*(recipe.make() for recipe in self._recipes))


# --------------------------------------------------------------------
class RecipeSequence(PolyRecipe):
    def __init__(self, *recipes: Recipe):
        super().__init__(*recipes)

    async def make(self):
        for recipe in self._recipes:
            await recipe.make()


# --------------------------------------------------------------------
class FileRecipe(Recipe):
    """ A recipe for creating a single file or directory. """

    def __init__(self, path: Path, requires: Optional[List[Recipe]] = None):
        super().__init__(requires)
        self.path = path

    @property
    def creates(self) -> List[Artifact]:
        return [File(self.path)]


# --------------------------------------------------------------------
class StaticFileRecipe(FileRecipe):
    """ A recipe for static files that must exist. """

    def __init__(self, path: Path):
        super().__init__(path)

    async def make(self):
        raise BuildError(f"A required file is missing: {self.path}")
